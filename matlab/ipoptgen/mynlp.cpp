#include "mynlp.hpp"
#include <cassert>
using namespace Ipopt;

bool HS071_NLP::get_nlp_info(Index& n, Index& m, Index& nnz_jac_g, Index& nnz_h_lag, IndexStyleEnum& index_style)
{
  n = 16;
  m = 49;
  nnz_jac_g = 87;
  nnz_h_lag = 10;
  index_style = TNLP::C_STYLE;
  return true;
}

bool HS071_NLP::get_bounds_info(Index n, Number* x_l, Number* x_u, Index m, Number* g_l, Number* g_u)
{
  x_l[0] = 0.000000;
  x_u[0] = 8.940000;
  x_l[1] = 0.000000;
  x_u[1] = 8.940000;
  x_l[2] = 0.000000;
  x_u[2] = 8.940000;
  x_l[3] = 0.000000;
  x_u[3] = 8.940000;
  x_l[4] = 0.000000;
  x_u[4] = 8.940000;
  x_l[5] = 0.000000;
  x_u[5] = 8.940000;
  x_l[6] = 0.000000;
  x_u[6] = 8.940000;
  x_l[7] = 0.000000;
  x_u[7] = 8.940000;
  x_l[8] = 0.000000;
  x_u[8] = 8.940000;
  x_l[9] = 0.000000;
  x_u[9] = 8.940000;
  x_l[10] = 0.000000;
  x_u[10] = 8.940000;
  x_l[11] = 0.000000;
  x_u[11] = 8.940000;
  x_l[12] = 0.000000;
  x_u[12] = 8.940000;
  x_l[13] = 0.000000;
  x_u[13] = 8.940000;
  x_l[14] = 0.000000;
  x_u[14] = 8.940000;
  x_l[15] = 0.000000;
  x_u[15] = 8.940000;
  g_l[0] = 0.000000;
  g_u[0] = 8.940000;
  g_l[1] = 0.000000;
  g_u[1] = 8.940000;
  g_l[2] = 0.000000;
  g_u[2] = 8.940000;
  g_l[3] = 0.000000;
  g_u[3] = 8.940000;
  g_l[4] = 0.000000;
  g_u[4] = 8.940000;
  g_l[5] = 0.000000;
  g_u[5] = 8.940000;
  g_l[6] = 0.000000;
  g_u[6] = 8.940000;
  g_l[7] = 0.000000;
  g_u[7] = 8.940000;
  g_l[8] = 0.000000;
  g_u[8] = 8.940000;
  g_l[9] = 0.000000;
  g_u[9] = 8.940000;
  g_l[10] = 0.000000;
  g_u[10] = 8.940000;
  g_l[11] = 0.000000;
  g_u[11] = 8.940000;
  g_l[12] = 0.000000;
  g_u[12] = 8.940000;
  g_l[13] = 0.000000;
  g_u[13] = 8.940000;
  g_l[14] = 0.000000;
  g_u[14] = 8.940000;
  g_l[15] = 0.000000;
  g_u[15] = 8.940000;
  g_l[16] = 0.000000;
  g_u[16] = 8.940000;
  g_l[17] = 0.000000;
  g_u[17] = 8.940000;
  g_l[18] = 0.000000;
  g_u[18] = 8.940000;
  g_l[19] = 0.000000;
  g_u[19] = 8.940000;
  g_l[20] = 0.000000;
  g_u[20] = 8.940000;
  g_l[21] = 0.000000;
  g_u[21] = 8.940000;
  g_l[22] = 0.000000;
  g_u[22] = 8.940000;
  g_l[23] = 0.000000;
  g_u[23] = 8.940000;
  g_l[24] = 0.000000;
  g_u[24] = 8.940000;
  g_l[25] = 0.000000;
  g_u[25] = 8.940000;
  g_l[26] = 0.000000;
  g_u[26] = 8.940000;
  g_l[27] = 0.000000;
  g_u[27] = 8.940000;
  g_l[28] = 0.000000;
  g_u[28] = 4.698138;
  g_l[29] = 0.000000;
  g_u[29] = 4.698138;
  g_l[30] = 0.000000;
  g_u[30] = 4.698138;
  g_l[31] = 0.000000;
  g_u[31] = 4.698138;
  g_l[32] = 0.000000;
  g_u[32] = 4.698138;
  g_l[33] = 0.000000;
  g_u[33] = 4.698138;
  g_l[34] = 0.000000;
  g_u[34] = 4.698138;
  g_l[35] = 0.000000;
  g_u[35] = 8.940000;
  g_l[36] = 0.000000;
  g_u[36] = 8.940000;
  g_l[37] = 0.000000;
  g_u[37] = 8.940000;
  g_l[38] = 0.000000;
  g_u[38] = 8.940000;
  g_l[39] = 0.000000;
  g_u[39] = 8.940000;
  g_l[40] = 0.000000;
  g_u[40] = 8.940000;
  g_l[41] = 0.000000;
  g_u[41] = 8.940000;
  g_l[42] = 0.000000;
  g_u[42] = 0.000000;
  g_l[43] = 0.000000;
  g_u[43] = 0.000000;
  g_l[44] = 0.000000;
  g_u[44] = 0.000000;
  g_l[45] = 0.000000;
  g_u[45] = 0.000000;
  g_l[46] = 0.000000;
  g_u[46] = 0.000000;
  g_l[47] = 0.000000;
  g_u[47] = 0.000000;
  g_l[48] = -20000000000000000000.000000;
  g_u[48] = 0.000000;
  return true;
}

bool HS071_NLP::get_starting_point(Index n, bool init_x, Number* x, bool init_z, Number* z_L, Number* z_U, Index m, bool init_lambda, Number* lambda)
{
  assert(init_x == true);
  assert(init_z == false);
  assert(init_lambda == false);

  x[0] = 0.000000;
  x[1] = 8.557047;
  x[2] = 0.000000;
  x[3] = 3.020134;
  x[4] = 0.000000;
  x[5] = 6.879195;
  x[6] = 4.698138;
  x[7] = 4.698138;
  x[8] = 0.000000;
  x[9] = 5.201342;
  x[10] = 0.000000;
  x[11] = 4.513650;
  x[12] = 0.000000;
  x[13] = 6.879195;
  x[14] = 4.698138;
  x[15] = 4.698138;
  return true;
}

bool HS071_NLP::eval_f(Index n, const Number* x, bool new_x, Number& obj_value)
{
  obj_value = x[0]+x[1]*(1.3E1/1.0E1)+x[2]+x[3]*(1.3E1/1.0E1)+x[4]+x[5]*(1.3E1/1.0E1)+x[8]+x[9]*(1.3E1/1.0E1)+x[10]+x[11]*(1.3E1/1.0E1)+x[12]+x[13]*(1.3E1/1.0E1);
  return true;
}

bool HS071_NLP::eval_grad_f(Index n, const Number* x, bool new_x, Number* grad_f)
{
  grad_f[0] = 1.0;
  grad_f[1] = 1.3E1/1.0E1;
  grad_f[2] = 1.0;
  grad_f[3] = 1.3E1/1.0E1;
  grad_f[4] = 1.0;
  grad_f[5] = 1.3E1/1.0E1;
  grad_f[8] = 1.0;
  grad_f[9] = 1.3E1/1.0E1;
  grad_f[10] = 1.0;
  grad_f[11] = 1.3E1/1.0E1;
  grad_f[12] = 1.0;
  grad_f[13] = 1.3E1/1.0E1;
  return true;
}

bool HS071_NLP::eval_g(Index n, const Number* x, bool new_x, Index m, Number* g)
{
  g[0] = 8.493;
  g[1] = x[6]*(-1.0/4.0)+(8.5E1/2.0)/x[1]+3.53875;
  g[2] = x[6]*(-1.0/3.0)+6.8E1/x[1];
  g[3] = x[6]*(-1.0/4.0)+(1.53E2/2.0)/x[1]-2.12325;
  g[4] = 6.8E1/x[1]-2.831;
  g[5] = x[6]*(5.0/1.2E1)+(8.5E1/2.0)/x[1]-2.12325;
  g[6] = x[6];
  g[7] = x[6];
  g[8] = x[6]*(5.0/1.2E1)-x[7]*(1.0/4.0)+1.5E1/x[3];
  g[9] = x[7]*(-1.0/3.0)+2.4E1/x[3];
  g[10] = x[6]*(-1.0/4.0)-x[7]*(1.0/4.0)+2.7E1/x[3];
  g[11] = x[6]*(-1.0/3.0)+2.4E1/x[3];
  g[12] = x[6]*(-1.0/4.0)+x[7]*(5.0/1.2E1)+1.5E1/x[3];
  g[13] = x[7];
  g[14] = x[7];
  g[15] = x[7]*(5.0/1.2E1)+(2.05E2/6.0)/x[5];
  g[16] = (1.64E2/3.0)/x[5];
  g[17] = x[7]*(-1.0/4.0)+(1.23E2/2.0)/x[5];
  g[18] = x[7]*(-1.0/3.0)+(1.64E2/3.0)/x[5];
  g[19] = x[7]*(-1.0/4.0)+(2.05E2/6.0)/x[5];
  g[21] = 8.493;
  g[22] = x[14]*(-1.0/4.0)+(1.55E2/6.0)/x[9]+3.53875;
  g[23] = x[14]*(-1.0/3.0)+(1.24E2/3.0)/x[9];
  g[24] = x[14]*(-1.0/4.0)+(9.3E1/2.0)/x[9]-2.12325;
  g[25] = (1.24E2/3.0)/x[9]-2.831;
  g[26] = x[14]*(5.0/1.2E1)+(1.55E2/6.0)/x[9]-2.12325;
  g[27] = x[14];
  g[28] = x[14];
  g[29] = x[14]*(5.0/1.2E1)-x[15]*(1.0/4.0)+(3.141592653589793*(1.5E1/4.0))/x[11];
  g[30] = x[15]*(-1.0/3.0)+(3.141592653589793*6.0)/x[11];
  g[31] = x[14]*(-1.0/4.0)-x[15]*(1.0/4.0)+(3.141592653589793*(2.7E1/4.0))/x[11];
  g[32] = x[14]*(-1.0/3.0)+(3.141592653589793*6.0)/x[11];
  g[33] = x[14]*(-1.0/4.0)+x[15]*(5.0/1.2E1)+(3.141592653589793*(1.5E1/4.0))/x[11];
  g[34] = x[15];
  g[35] = x[15];
  g[36] = x[15]*(5.0/1.2E1)+(2.05E2/6.0)/x[13];
  g[37] = (1.64E2/3.0)/x[13];
  g[38] = x[15]*(-1.0/4.0)+(1.23E2/2.0)/x[13];
  g[39] = x[15]*(-1.0/3.0)+(1.64E2/3.0)/x[13];
  g[40] = x[15]*(-1.0/4.0)+(2.05E2/6.0)/x[13];
  g[42] = x[0]*8.493;
  g[43] = x[2]*x[6];
  g[44] = x[4]*x[7];
  g[45] = x[8]*8.493;
  g[46] = x[10]*x[14];
  g[47] = x[12]*x[15];
  g[48] = x[0]+x[1]+x[2]+x[3]-x[8]-x[9]-x[10];
  return true;
}

bool HS071_NLP::eval_jac_g(Index n, const Number* x, bool new_x, Index m, Index nele_jac, Index* iRow, Index *jCol,  Number* values)
{
  if (values == NULL) {
    iRow[0] = 42; jCol[0] = 0;
    iRow[1] = 48; jCol[1] = 0;
    iRow[2] = 1; jCol[2] = 1;
    iRow[3] = 2; jCol[3] = 1;
    iRow[4] = 3; jCol[4] = 1;
    iRow[5] = 4; jCol[5] = 1;
    iRow[6] = 5; jCol[6] = 1;
    iRow[7] = 48; jCol[7] = 1;
    iRow[8] = 43; jCol[8] = 2;
    iRow[9] = 48; jCol[9] = 2;
    iRow[10] = 8; jCol[10] = 3;
    iRow[11] = 9; jCol[11] = 3;
    iRow[12] = 10; jCol[12] = 3;
    iRow[13] = 11; jCol[13] = 3;
    iRow[14] = 12; jCol[14] = 3;
    iRow[15] = 48; jCol[15] = 3;
    iRow[16] = 44; jCol[16] = 4;
    iRow[17] = 15; jCol[17] = 5;
    iRow[18] = 16; jCol[18] = 5;
    iRow[19] = 17; jCol[19] = 5;
    iRow[20] = 18; jCol[20] = 5;
    iRow[21] = 19; jCol[21] = 5;
    iRow[22] = 1; jCol[22] = 6;
    iRow[23] = 2; jCol[23] = 6;
    iRow[24] = 3; jCol[24] = 6;
    iRow[25] = 5; jCol[25] = 6;
    iRow[26] = 6; jCol[26] = 6;
    iRow[27] = 7; jCol[27] = 6;
    iRow[28] = 8; jCol[28] = 6;
    iRow[29] = 10; jCol[29] = 6;
    iRow[30] = 11; jCol[30] = 6;
    iRow[31] = 12; jCol[31] = 6;
    iRow[32] = 43; jCol[32] = 6;
    iRow[33] = 8; jCol[33] = 7;
    iRow[34] = 9; jCol[34] = 7;
    iRow[35] = 10; jCol[35] = 7;
    iRow[36] = 12; jCol[36] = 7;
    iRow[37] = 13; jCol[37] = 7;
    iRow[38] = 14; jCol[38] = 7;
    iRow[39] = 15; jCol[39] = 7;
    iRow[40] = 17; jCol[40] = 7;
    iRow[41] = 18; jCol[41] = 7;
    iRow[42] = 19; jCol[42] = 7;
    iRow[43] = 44; jCol[43] = 7;
    iRow[44] = 45; jCol[44] = 8;
    iRow[45] = 48; jCol[45] = 8;
    iRow[46] = 22; jCol[46] = 9;
    iRow[47] = 23; jCol[47] = 9;
    iRow[48] = 24; jCol[48] = 9;
    iRow[49] = 25; jCol[49] = 9;
    iRow[50] = 26; jCol[50] = 9;
    iRow[51] = 48; jCol[51] = 9;
    iRow[52] = 46; jCol[52] = 10;
    iRow[53] = 48; jCol[53] = 10;
    iRow[54] = 29; jCol[54] = 11;
    iRow[55] = 30; jCol[55] = 11;
    iRow[56] = 31; jCol[56] = 11;
    iRow[57] = 32; jCol[57] = 11;
    iRow[58] = 33; jCol[58] = 11;
    iRow[59] = 47; jCol[59] = 12;
    iRow[60] = 36; jCol[60] = 13;
    iRow[61] = 37; jCol[61] = 13;
    iRow[62] = 38; jCol[62] = 13;
    iRow[63] = 39; jCol[63] = 13;
    iRow[64] = 40; jCol[64] = 13;
    iRow[65] = 22; jCol[65] = 14;
    iRow[66] = 23; jCol[66] = 14;
    iRow[67] = 24; jCol[67] = 14;
    iRow[68] = 26; jCol[68] = 14;
    iRow[69] = 27; jCol[69] = 14;
    iRow[70] = 28; jCol[70] = 14;
    iRow[71] = 29; jCol[71] = 14;
    iRow[72] = 31; jCol[72] = 14;
    iRow[73] = 32; jCol[73] = 14;
    iRow[74] = 33; jCol[74] = 14;
    iRow[75] = 46; jCol[75] = 14;
    iRow[76] = 29; jCol[76] = 15;
    iRow[77] = 30; jCol[77] = 15;
    iRow[78] = 31; jCol[78] = 15;
    iRow[79] = 33; jCol[79] = 15;
    iRow[80] = 34; jCol[80] = 15;
    iRow[81] = 35; jCol[81] = 15;
    iRow[82] = 36; jCol[82] = 15;
    iRow[83] = 38; jCol[83] = 15;
    iRow[84] = 39; jCol[84] = 15;
    iRow[85] = 40; jCol[85] = 15;
    iRow[86] = 47; jCol[86] = 15;
  }
  else {
    values[0] = 8.493;
    values[1] = 1.0;
    values[2] = 1.0/(x[1]*x[1])*(-8.5E1/2.0);
    values[3] = 1.0/(x[1]*x[1])*-6.8E1;
    values[4] = 1.0/(x[1]*x[1])*(-1.53E2/2.0);
    values[5] = 1.0/(x[1]*x[1])*-6.8E1;
    values[6] = 1.0/(x[1]*x[1])*(-8.5E1/2.0);
    values[7] = 1.0;
    values[8] = x[6];
    values[9] = 1.0;
    values[10] = 1.0/(x[3]*x[3])*-1.5E1;
    values[11] = 1.0/(x[3]*x[3])*-2.4E1;
    values[12] = 1.0/(x[3]*x[3])*-2.7E1;
    values[13] = 1.0/(x[3]*x[3])*-2.4E1;
    values[14] = 1.0/(x[3]*x[3])*-1.5E1;
    values[15] = 1.0;
    values[16] = x[7];
    values[17] = 1.0/(x[5]*x[5])*(-2.05E2/6.0);
    values[18] = 1.0/(x[5]*x[5])*(-1.64E2/3.0);
    values[19] = 1.0/(x[5]*x[5])*(-1.23E2/2.0);
    values[20] = 1.0/(x[5]*x[5])*(-1.64E2/3.0);
    values[21] = 1.0/(x[5]*x[5])*(-2.05E2/6.0);
    values[22] = -1.0/4.0;
    values[23] = -1.0/3.0;
    values[24] = -1.0/4.0;
    values[25] = 5.0/1.2E1;
    values[26] = 1.0;
    values[27] = 1.0;
    values[28] = 5.0/1.2E1;
    values[29] = -1.0/4.0;
    values[30] = -1.0/3.0;
    values[31] = -1.0/4.0;
    values[32] = x[2];
    values[33] = -1.0/4.0;
    values[34] = -1.0/3.0;
    values[35] = -1.0/4.0;
    values[36] = 5.0/1.2E1;
    values[37] = 1.0;
    values[38] = 1.0;
    values[39] = 5.0/1.2E1;
    values[40] = -1.0/4.0;
    values[41] = -1.0/3.0;
    values[42] = -1.0/4.0;
    values[43] = x[4];
    values[44] = 8.493;
    values[45] = -1.0;
    values[46] = 1.0/(x[9]*x[9])*(-1.55E2/6.0);
    values[47] = 1.0/(x[9]*x[9])*(-1.24E2/3.0);
    values[48] = 1.0/(x[9]*x[9])*(-9.3E1/2.0);
    values[49] = 1.0/(x[9]*x[9])*(-1.24E2/3.0);
    values[50] = 1.0/(x[9]*x[9])*(-1.55E2/6.0);
    values[51] = -1.0;
    values[52] = x[14];
    values[53] = -1.0;
    values[54] = 3.141592653589793*1.0/(x[11]*x[11])*(-1.5E1/4.0);
    values[55] = 3.141592653589793*1.0/(x[11]*x[11])*-6.0;
    values[56] = 3.141592653589793*1.0/(x[11]*x[11])*(-2.7E1/4.0);
    values[57] = 3.141592653589793*1.0/(x[11]*x[11])*-6.0;
    values[58] = 3.141592653589793*1.0/(x[11]*x[11])*(-1.5E1/4.0);
    values[59] = x[15];
    values[60] = 1.0/(x[13]*x[13])*(-2.05E2/6.0);
    values[61] = 1.0/(x[13]*x[13])*(-1.64E2/3.0);
    values[62] = 1.0/(x[13]*x[13])*(-1.23E2/2.0);
    values[63] = 1.0/(x[13]*x[13])*(-1.64E2/3.0);
    values[64] = 1.0/(x[13]*x[13])*(-2.05E2/6.0);
    values[65] = -1.0/4.0;
    values[66] = -1.0/3.0;
    values[67] = -1.0/4.0;
    values[68] = 5.0/1.2E1;
    values[69] = 1.0;
    values[70] = 1.0;
    values[71] = 5.0/1.2E1;
    values[72] = -1.0/4.0;
    values[73] = -1.0/3.0;
    values[74] = -1.0/4.0;
    values[75] = x[10];
    values[76] = -1.0/4.0;
    values[77] = -1.0/3.0;
    values[78] = -1.0/4.0;
    values[79] = 5.0/1.2E1;
    values[80] = 1.0;
    values[81] = 1.0;
    values[82] = 5.0/1.2E1;
    values[83] = -1.0/4.0;
    values[84] = -1.0/3.0;
    values[85] = -1.0/4.0;
    values[86] = x[12];
  }
  return true;
}
bool HS071_NLP::eval_h(Index n, const Number* x, bool new_x, Number obj_factor, Index m, const Number* lambda, bool new_lambda, Index nele_hess, Index* iRow, Index* jCol, Number* values)
{
  if (values == NULL) {
    iRow[0] = 1; jCol[0] = 1;
    iRow[1] = 6; jCol[1] = 2;
    iRow[2] = 3; jCol[2] = 3;
    iRow[3] = 7; jCol[3] = 4;
    iRow[4] = 5; jCol[4] = 5;
    iRow[5] = 9; jCol[5] = 9;
    iRow[6] = 14; jCol[6] = 10;
    iRow[7] = 11; jCol[7] = 11;
    iRow[8] = 15; jCol[8] = 12;
    iRow[9] = 13; jCol[9] = 13;
  }
  else {
    values[0] = lambda[1]*1.0/(x[1]*x[1]*x[1])*8.5E1+lambda[2]*1.0/(x[1]*x[1]*x[1])*1.36E2+lambda[3]*1.0/(x[1]*x[1]*x[1])*1.53E2+lambda[4]*1.0/(x[1]*x[1]*x[1])*1.36E2+lambda[5]*1.0/(x[1]*x[1]*x[1])*8.5E1;
    values[1] = lambda[43];
    values[2] = lambda[8]*1.0/(x[3]*x[3]*x[3])*3.0E1+lambda[9]*1.0/(x[3]*x[3]*x[3])*4.8E1+lambda[10]*1.0/(x[3]*x[3]*x[3])*5.4E1+lambda[11]*1.0/(x[3]*x[3]*x[3])*4.8E1+lambda[12]*1.0/(x[3]*x[3]*x[3])*3.0E1;
    values[3] = lambda[44];
    values[4] = lambda[15]*1.0/(x[5]*x[5]*x[5])*(2.05E2/3.0)+lambda[16]*1.0/(x[5]*x[5]*x[5])*(3.28E2/3.0)+lambda[17]*1.0/(x[5]*x[5]*x[5])*1.23E2+lambda[18]*1.0/(x[5]*x[5]*x[5])*(3.28E2/3.0)+lambda[19]*1.0/(x[5]*x[5]*x[5])*(2.05E2/3.0);
    values[5] = lambda[22]*1.0/(x[9]*x[9]*x[9])*(1.55E2/3.0)+lambda[23]*1.0/(x[9]*x[9]*x[9])*(2.48E2/3.0)+lambda[24]*1.0/(x[9]*x[9]*x[9])*9.3E1+lambda[25]*1.0/(x[9]*x[9]*x[9])*(2.48E2/3.0)+lambda[26]*1.0/(x[9]*x[9]*x[9])*(1.55E2/3.0);
    values[6] = lambda[46];
    values[7] = 3.141592653589793*lambda[29]*1.0/(x[11]*x[11]*x[11])*(1.5E1/2.0)+3.141592653589793*lambda[30]*1.0/(x[11]*x[11]*x[11])*1.2E1+3.141592653589793*lambda[31]*1.0/(x[11]*x[11]*x[11])*(2.7E1/2.0)+3.141592653589793*lambda[32]*1.0/(x[11]*x[11]*x[11])*1.2E1+3.141592653589793*lambda[33]*1.0/(x[11]*x[11]*x[11])*(1.5E1/2.0);
    values[8] = lambda[47];
    values[9] = lambda[36]*1.0/(x[13]*x[13]*x[13])*(2.05E2/3.0)+lambda[37]*1.0/(x[13]*x[13]*x[13])*(3.28E2/3.0)+lambda[38]*1.0/(x[13]*x[13]*x[13])*1.23E2+lambda[39]*1.0/(x[13]*x[13]*x[13])*(3.28E2/3.0)+lambda[40]*1.0/(x[13]*x[13]*x[13])*(2.05E2/3.0);
  }
  return true;
}
